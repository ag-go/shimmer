<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>Go wasm</title>
	<style>
		.image {
			display: block;
			max-height: 25rem;
			width: 49%;
			float: left;
			border: 2px solid gray;
			margin-right: 2px;
		}
		.separator {
			clear: both;
		}
	</style>
</head>
<body>
	<div id="status"></div>
	<input type="file" id="uploader" />
	<button id="close">Shutdown app</button>
	<br />
	<label for="brightness">Brightness</label>
	<input type="range" min="-1" max="1" value="0" step="0.1" id="brightness">
	<label for="contrast">Contrast</label>
	<input type="range" min="-1" max="1" value="0" step="0.1" id="contrast">
	<label for="hue">Hue</label>
	<input type="range" min="-360" max="360" value="0" step="10" id="hue">
	<label for="sat">Saturation</label>
	<input type="range" min="-1" max="1" value="0" step="0.1" id="sat">

	<div class="separator">Results:</div>
	<div>
		<image id="sourceImg" class="image" />
		<image id="targetImg" class="image" />
	</div>


	<script src="wasm_loader.js"></script>
	<script>
		const go = new Go();
		// memoryBytes is an Uint8Array pointing to the webassembly linear memory.
		let memoryBytes;
		let mod, inst, bytes;
		let imageType;
		document.getElementById('status').innerText = "Initializing wasm...";
		WebAssembly.instantiateStreaming(
			fetch("shimmer.wasm", {cache: 'no-cache'}), go.importObject).then((result) => {
			mod = result.module;
			inst = result.instance;
			memoryBytes = new Uint8Array(inst.exports.mem.buffer)
			document.getElementById('status').innerText = "Initialization complete.";
			run();
		});

		async function run() {
			await go.run(inst);
		}

		// gotMem sets the webassembly linear memory with the image buffer result
		// at the slice header pointer passed from Go.
		function gotMem(pointer) {
			memoryBytes.set(bytes, pointer);
			// Now the image can be loaded from the slice.
			loadImage();
		}

		// displayImage takes the pointer to the target image in the wasm linear memory
		// and its length. Converts to base64 and populates the target image src.
		function displayImage(pointer, length) {
			let resultBytes = memoryBytes.slice(pointer, pointer + length);
			let b64 = base64ArrayBuffer(resultBytes);
			let src = 'data:' + imageType + ';base64,' + b64;
			document.getElementById('targetImg').src = src;
		}

		document.getElementById('uploader').addEventListener('change', function() {
			let reader = new FileReader();
			reader.onload = (ev) => {
				bytes = new Uint8Array(ev.target.result);
				initMem(bytes.length);
				let b64 = base64ArrayBuffer(bytes);
				document.getElementById("sourceImg").src = 'data:' + imageType + ';base64,' + b64;
			};
			imageType = this.files[0].type;
			reader.readAsArrayBuffer(this.files[0]);
		});

		function base64ArrayBuffer(bytes) {
			var base64    = ''
			var encodings = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
			var byteLength    = bytes.byteLength
			var byteRemainder = byteLength % 3
			var mainLength    = byteLength - byteRemainder
			var a, b, c, d
			var chunk
			// Main loop deals with bytes in chunks of 3
			for (var i = 0; i < mainLength; i = i + 3) {
					// Combine the three bytes into a single integer
					chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2]
					// Use bitmasks to extract 6-bit segments from the triplet
					a = (chunk & 16515072) >> 18 // 16515072 = (2^6 - 1) << 18
					b = (chunk & 258048)   >> 12 // 258048   = (2^6 - 1) << 12
					c = (chunk & 4032)     >>  6 // 4032     = (2^6 - 1) << 6
					d = chunk & 63               // 63       = 2^6 - 1
					// Convert the raw binary segments to the appropriate ASCII encoding
					base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d]
			}
			// Deal with the remaining bytes and padding
			if (byteRemainder == 1) {
					chunk = bytes[mainLength]
					a = (chunk & 252) >> 2 // 252 = (2^6 - 1) << 2
					// Set the 4 least significant bits to zero
					b = (chunk & 3)   << 4 // 3   = 2^2 - 1
					base64 += encodings[a] + encodings[b] + '=='
			} else if (byteRemainder == 2) {
					chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1]
					a = (chunk & 64512) >> 10 // 64512 = (2^6 - 1) << 10
					b = (chunk & 1008)  >>  4 // 1008  = (2^6 - 1) << 4
					// Set the 2 least significant bits to zero
					c = (chunk & 15)    <<  2 // 15    = 2^4 - 1
					base64 += encodings[a] + encodings[b] + encodings[c] + '='
			}
			return base64
		}
	</script>
</body>
</html>
